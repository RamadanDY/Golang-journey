this is how to save values in arrays and slices
//Array 
bookings = [50]string
booking[0] = "hello"

//slices we use the append method
bookings = []string
bookings = append(bookings,"hello")

‚úÖ How to tell them apart

Syntax

Array: [N]Type (e.g., [3]int)

Slice: []Type (e.g., []int) and it is dynamic ie it can grow 


examples


mySlice := []int{1, 2, 3, 4, 5, 65, 3}
	fmt.Println(mySlice)

myArray := [1]string{"hekklo"}
	fmt.Println(myArray)


## **1. Arrays in Go**

* An **array** is a **fixed-length** sequence of elements of the same type.
* Size is part of the array type ‚Üí `[5]int` is different from `[10]int`.
* Example:

  ```go
  package main
  import "fmt"

  func main() {
      var nums [3]int            // array of 3 integers, default 0
      nums[0] = 10
      nums[1] = 20
      nums[2] = 30
      fmt.Println(nums)          // [10 20 30]

      arr := [4]string{"a","b","c","d"}
      fmt.Println(arr)           // [a b c d]
  }
  ```

‚ö†Ô∏è Arrays in Go are rarely used directly in applications because of their **fixed size**.

---

## **2. Slices in Go**
 Slices are similar to arrays, but are more powerful and flexible.

Like arrays, slices are also used to store multiple values of the same type in a single variable.

However, unlike arrays, the length of a slice can grow and shrink as you see fit.

In Go, there are several ways to create a slice:

    1.Using the []datatype{values} format
    2.Create a slice from an array
    3.Using the make() function

* Example:

  ```go
  package main
  import "fmt"

  func main() {
      nums := []int{1, 2, 3, 4, 5}  // slice, not array
      fmt.Println(nums)             // [1 2 3 4 5]
      fmt.Println(len(nums))        // 5 (length)
      fmt.Println(cap(nums))        // 5 (capacity)

      nums = append(nums, 6)        // can grow dynamically
      fmt.Println(nums)             // [1 2 3 4 5 6]
      fmt.Println(len(nums))        // 6
      fmt.Println(cap(nums))        // might increase automatically
  }
  ```

---

## **3. Relationship Between Arrays and Slices**

* A slice is built on top of an array.
* Example:

  ```go
  arr := [5]int{10, 20, 30, 40, 50}
  slice := arr[1:4]     // slice of arr from index 1 up to 3
  fmt.Println(slice)    // [20 30 40]
  ```

If you change the slice, you change the array too (because they share the same memory):

```go
slice[0] = 99
fmt.Println(arr)   // [10 99 30 40 50]
```

---

## **4. Key Differences**

| Feature     | Array                 | Slice                            |
| ----------- | --------------------- | -------------------------------- |
| Size        | Fixed at compile time | Dynamic (can grow/shrink)        |
| Use         | Rarely used directly  | Commonly used in Go programs     |
| Memory      | Holds the data itself | Holds reference to an array      |
| Flexibility | Rigid                 | Very flexible (`append`, `copy`) |

---

‚úÖ **Summary**:

* **Arrays** = fixed size, value type.
* **Slices** = flexible, dynamic view into an array ‚Üí widely used in Go.

---

üëâ Do you want me to also show you **how slices manage their capacity under the hood** (like when you `append` beyond the capacity)? That‚Äôs an important ‚Äúgotcha‚Äù for Go devs.

package main

import "fmt"

func main() {
	fmt.Println("hello")
	// slice
	myslice := [10]int{1, 2, 3, 4, 5, 6, 7}
	// this is  to show the capacity  of the slice or the array
	fmt.Println(cap(myslice))
}


///////////////lets append a slice 
package main

import "fmt"

func main() {
	fmt.Println("hello")
	// slice
	myslice := []int{1, 2, 3, 4, 5, 6, 7}
	// this is  to show the capacity  of the slice or the array
	fmt.Println(cap(myslice))
	name := append(myslice, 2)
	fmt.Println(name)
}


package main

import "fmt"

func main() {
	fmt.Println("hello")
	// slice ie cahnging the value of the index 
	myslice := [10]int{1, 2, 3, 4, 5, 6, 7}
	// this is  to show the capacity  of the slice or the array
	myslice[2] = 26
	fmt.Println(myslice)
}
